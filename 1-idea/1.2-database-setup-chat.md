# 1.2.1: Initial Schema Analysis

```
Based on the product requirements document we created, I'll help you design a database schema for your SaaS application. Let's start by identifying the core entities and their relationships.

Please paste your product requirements document here, or if it's too long, provide a summary of the key features that will require database storage. Include information about:

1. User types (admin, regular users, etc.)
2. Main objects your system will manage (e.g., projects, tasks, documents)
3. Any relationships between these objects
4. Any specific data requirements (file storage, metrics tracking, etc.)

[Paste your PRD or summary here]
```

# 1.2.2: Core Tables Design

```
Thank you for sharing that information. Based on your requirements, here's my proposed database schema for your SaaS application:

## Core Tables

[AI WILL GENERATE TABLES BASED ON USER INPUT - EXAMPLE:]
1. **users** - Store user information
   - id: uuid (primary key)
   - email: text (unique)
   - created_at: timestamp
   - updated_at: timestamp
   - [additional user fields as needed]

2. **profiles** - Extended user profile information
   - id: uuid (primary key, references users.id)
   - full_name: text
   - avatar_url: text
   - [additional profile fields]

3. **[CUSTOM ENTITY]** - [Description]
   - id: uuid (primary key)
   - name: text
   - [other fields]
   - user_id: uuid (foreign key to users)
   
4. **[CUSTOM ENTITY]** - [Description]
   - id: uuid (primary key)
   - [fields]
   - [relationships]

## Relationships

[AI WILL DESCRIBE RELATIONSHIPS BETWEEN TABLES]

## Does this schema align with your vision for the application? 

Please provide feedback:
1. Are there any tables or fields missing?
2. Should any of the relationships be different?
3. Any additional data you need to store that isn't covered?

[Provide your feedback here]
```

# 1.2.3: Authentication & Subscription Tables

```
Thank you for your feedback. Now, let's add the necessary authentication and subscription management tables that every SaaS application needs:

## Authentication Tables

Since we'll be using Supabase, these tables will be handled by the auth schema:

1. **auth.users** - Managed by Supabase Auth
   - This table stores authentication information and is handled automatically
   - We'll link to this using the UUID from our application tables

## Subscription Management

For handling subscriptions, we'll need:

1. **subscriptions** - Track user subscription status
   - id: uuid (primary key)
   - user_id: uuid (references auth.users.id)
   - status: text (active, canceled, etc.)
   - price_id: text (reference to Stripe price ID)
   - quantity: integer
   - cancel_at_period_end: boolean
   - created_at: timestamp
   - current_period_start: timestamp
   - current_period_end: timestamp
   - ended_at: timestamp (nullable)
   - cancel_at: timestamp (nullable)
   - canceled_at: timestamp (nullable)
   - trial_start: timestamp (nullable)
   - trial_end: timestamp (nullable)

2. **pricing_tiers** - Define available subscription tiers
   - id: uuid (primary key)
   - name: text
   - description: text
   - price_monthly: integer (in cents)
   - price_yearly: integer (in cents)
   - stripe_price_id_monthly: text
   - stripe_price_id_yearly: text
   - features: jsonb (array of features included)
   - active: boolean
   - created_at: timestamp

Does this look good? Do you need any custom subscription or payment tracking beyond this standard setup?

[Provide your feedback here]
```

# 1.2.4: Row Level Security & Permissions

```
Now let's define Row Level Security (RLS) policies to ensure data security. These policies control who can access which rows in your database tables.

## Row Level Security Policies

[AI WILL GENERATE RLS POLICIES BASED ON USER INPUT - EXAMPLE:]

1. **users table**
   - Users can only read and update their own user data
   - Admins can read all user data but can only update specific fields

2. **profiles table**
   - Users can only read and update their own profiles
   - Admins can read all profiles but only update certain fields

3. **[CUSTOM ENTITY] table**
   - Users can only read and write their own records
   - Records can be shared with other users via a permissions table

## Functions & Triggers

We'll also need some helper functions and triggers:

1. **Create profile after user creation** - Automatically creates a profile when a new user signs up
2. **Handle subscription changes** - Updates user capabilities when subscription status changes
3. **[Additional functions based on your specific requirements]**

## Do these security policies and functions meet your needs?

Are there any specific access patterns or security requirements I've missed?

[Provide your feedback here]
```

# 1.2.5: Additional Features & Customization

```
Based on your feedback, let's add any additional database features needed for your specific application:

## Custom Functions

[AI WILL GENERATE CUSTOM FUNCTIONS BASED ON USER REQUIREMENTS - EXAMPLE:]

1. **get_user_dashboard_data()** - Function to efficiently retrieve all data needed for user dashboard
2. **calculate_usage_metrics()** - Track and calculate usage against subscription limits
3. **[Other custom functions]**

## Indexes & Performance Optimizations

To ensure your application performs well even as data grows:

1. **Indexes on frequently queried fields**
   - Add index on [field] for faster lookups
   - Create composite index on [fields] for common filter operations

2. **Materialized Views**
   - Create materialized view for [complex query] to improve dashboard performance

## Additional Custom Features

[ANY SPECIAL DATABASE FEATURES SPECIFIC TO THE APPLICATION]

Does this cover all the database functionality you'll need for your application? Any other special requirements or optimizations we should consider?

[Provide your feedback here]
```

# 1.2.6: Final Schema Review

```
Great! Let's review the complete database schema before generating the final SQL migration script:

## Core Tables
[AI LISTS ALL TABLES AND FIELDS]

## Authentication & Subscription Tables
[AI LISTS AUTH AND SUBSCRIPTION TABLES]

## Security Policies
[AI SUMMARIZES ALL RLS POLICIES]

## Functions & Triggers
[AI LISTS ALL FUNCTIONS AND TRIGGERS]

## Indexes & Optimizations
[AI LISTS PERFORMANCE OPTIMIZATIONS]

Please review this comprehensive schema and let me know if you'd like to make any final adjustments before I generate the SQL migration script.

[Provide any final feedback here]
```

# 1.2.7: SQL Migration Script Generation

```
Perfect! Based on our discussion and your final feedback, I'll now generate the complete SQL migration script that you can run in your Supabase project.

This script will:
1. Create all necessary tables
2. Set up relationships between tables
3. Implement Row Level Security policies
4. Create needed functions and triggers
5. Add indexes and optimizations

Here's the complete SQL migration script:

```sql
-- 000-initial-migration.sql

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Set up tables
[AI GENERATES COMPLETE TABLE CREATION SQL]

-- Set up relationships & foreign keys
[AI GENERATES FOREIGN KEY CONSTRAINTS]

-- Create RLS policies
[AI GENERATES RLS POLICY SQL]

-- Create functions & triggers
[AI GENERATES FUNCTION AND TRIGGER SQL]

-- Add indexes for performance
[AI GENERATES INDEX CREATION SQL]

-- Add sample data (optional)
[AI GENERATES SAMPLE DATA INSERTION SQL IF REQUESTED]
```

## How to use this migration script:

1. Go to your Supabase project dashboard
2. Navigate to the SQL Editor
3. Create a new query and paste this entire script
4. Run the script to create your database schema

The script includes comments to help you understand each section. After running this, your database will be fully set up with proper security policies and optimizations for your SaaS application.

Would you like me to explain any part of this script in more detail?
```