# Day 1: Create

[⬅️ Day 1 Overview](README.md)

## 1.4 Database Setup Introduction

**Goal**: Define the data structure (schema) required for the web application, using Supabase's declarative schema approach to create a series of schema files that will be used to generate SQL migrations for your database.

**Process**: Follow this chat pattern with an AI chat tool such as [Claude.ai](https://www.claude.ai). Pay attention to the notes in `[brackets]` and replace the brackets with your own thoughts and ideas.

**Timeframe**: 30-45 minutes

## Table of Contents
- [1.4.1: Initial Schema Analysis](#141-initial-schema-analysis)
- [1.4.2: Foundation Schema](#142-foundation-schema)
- [1.4.3: Profiles Schema](#143-profiles-schema)
- [1.4.4: Reference Schema](#144-reference-schema)
- [1.4.5: Config Schema (Optional)](#145-config-schema-optional)
- [1.4.6: Internal Schema (Optional)](#146-internal-schema-optional)
- [1.4.7: Core Entity Schemas](#147-core-entity-schemas)
- [1.4.8: Analytics Schema (Optional)](#148-analytics-schema-optional)
- [1.4.9: Audit Schema (Optional)](#149-audit-schema-optional)
- [1.4.10: Configuration Setup](#1410-configuration-setup)
- [1.4.11: Seed Data](#1411-seed-data)
- [1.4.12: Schema Validation](#1412-schema-validation)
- [1.4.13: Installation Instructions](#1413-installation-instructions)

Have this link open and ready to copy/paste in: [supabase-database-patterns.md](../0-learn/supabase-database-patterns.md)

## 1.4 Database Setup Generation

### 1.4.1: Initial Schema Analysis

```
You are a Supabase and PostgreSQL expert tasked with helping an entrepreneur analyze product requirements for a declarative database schema approach.

I'm using Supabase's declarative schema feature where I define my database structure in SQL files and generate migrations by diffing against my database. Please analyze my product requirements to help me plan my schema files structure.

Please paste your completed `product-requirements.md` document from step 1.1 and the `supabase-database-patterns.md` file below:

<product-requirements>
{{product-requirements.md}}
</product-requirements>

<supabase-database-patterns>
{{supabase-database-patterns.md}}
</supabase-database-patterns>

Supabase has reserved schemas with special purposes. My custom schemas should be organized as:

#### Custom Schema Structure
- `api` - User-generated content and application data, including user-specific instances of templates
- `internal` - Sensitive internal operations not directly accessible to users, financial data (credit balances, transactions), and system-generated records requiring special access controls
- `reference` - Publicly available lookup tables and reusable templates for features that have both templates and user customizations

#### Optional Custom Schemas (use if needed by requirements)
- `analytics` - Reporting data (primarily views)
- `audit` - Tracking changes
- `config` - Application configuration data
- `stripe` - Synced data from Stripe webhooks (if using Stripe)

Based on my product requirements, please:
1. Identify all essential database entities needed (tables, views, functions)
2. Group these into logical domains based on functionality
3. Recommend a file structure for schema files in the supabase/schemas directory
4. Suggest appropriate schema placement (api, internal, reference, etc.) for each entity
5. Identify any enums or custom types needed

The goal is to organize my database schema files by domain for better maintainability. For example:
- 00-foundation.sql (extensions, schemas, types)
- 01-profiles.sql (user profiles)
- 02-stripe.sql (payment integration)
- 03-reference.sql (lookup tables)
- 04-config.sql (application configuration)
- 05-internal.sql (sensitive internal operations)
- 10-[domain1].sql, 11-[domain2].sql, etc. (core entities by domain)
- 90-analytics.sql (reporting views and functions)
- 91-audit.sql (audit history and tracking)

Do not write any SQL yet - just analyze and organize the database requirements into logical schema file groupings.
```

### 1.4.2: Foundation Schema

```
Thank you for the initial analysis. Now I'd like to create my first schema file: `supabase/schemas/00-foundation.sql` which will establish the foundation of my database structure.

This file will ONLY contain:
1. Extensions that need to be explicitly enabled
2. Custom schemas creation (api, internal, reference, etc.)
3. Enums and custom types

The declarative schema approach requires defining the state I want my database to be in. Please generate the complete `00-foundation.sql` file based on the analysis of my product requirements.

Use clear comments and follow these principles:
- Only enable extensions that are truly needed
- Create all necessary custom schemas with descriptive comments
- Define all enums and custom types needed
- Place enums in the appropriate schema (usually reference)

Remember this is a declarative schema file, not a migration - define the final state, not the steps to get there.
```

### 1.4.3: Profiles Schema

```
Next, I need to create the `supabase/schemas/01-profiles.sql` file that will define user profile tables and related structures.

This file should include:
1. The profiles table that extends auth.users
2. Any tables that store user-specific settings or preferences
3. Any tables related to user roles or permissions
4. Required triggers or functions specifically related to user profiles

Generate the complete `01-profiles.sql` file following these patterns:
- Follow the Supabase best practice of storing extended user data in api.profiles
- Link profiles to auth users with a foreign key reference
- Include appropriate timestamp fields (created_at, updated_at)
- Keep in mind this is a declarative schema file defining the final state

Remember, with declarative schemas, I'm declaring the state I want my database to be in, not the steps to create it.
```

### 1.4.4: Reference Schema

```
Now I need to create the `supabase/schemas/03-reference.sql` file for lookup tables and reference data.

This file should include:
1. All reference/lookup tables needed by my application
2. Tables that store configuration data or templates
3. Standard options for dropdown menus or selectable values

Generate the complete `03-reference.sql` file following these patterns:
- Place reference tables in the reference schema
- Ensure tables have appropriate constraints and descriptions
- Include clear comments explaining the purpose of each table
- Define the tables that represent static data that rarely changes

This is a declarative schema file defining the state I want these reference tables to have.
```

### 1.4.5: Config Schema (Optional)

```
Now I'd like to create the `supabase/schemas/04-config.sql` file for application configuration data.

This optional file should include:
1. Tables that store application-wide configuration settings
2. Feature flags and toggles
3. System parameters and settings
4. Any other configuration data needed by the application

Generate the complete `04-config.sql` file following these patterns:
- Place configuration tables in the config schema
- Create appropriate structures for storing key-value pairs or structured configuration
- Include versioning if configuration changes need to be tracked
- Consider access patterns (who needs to read/write this data)

This is a declarative schema file defining the state I want these configuration tables to have. If my application doesn't require configuration tables based on the requirements, please indicate that this file can be skipped.
```

### 1.4.6: Internal Schema (Optional)

```
Now I'd like to create the `supabase/schemas/05-internal.sql` file for sensitive internal operations.

This optional file should include:
1. Tables that store sensitive data not directly accessible to users
2. System-generated records requiring special access controls
3. Tables for internal operations and administrative functions
4. Any tables requiring elevated permissions to access

Generate the complete `05-internal.sql` file following these patterns:
- Place these tables in the internal schema
- Implement appropriate constraints and security considerations
- Structure tables for system processes rather than user interactions
- Keep sensitive data isolated from user-accessible schemas

This is a declarative schema file defining the state I want these internal tables to have. If my application doesn't require internal tables based on the requirements, please indicate that this file can be skipped.
```

### 1.4.7: Core Entity Schemas

```
Now I need to create the core entity schema files, organized by domain. Based on the initial analysis, please create a schema file for the [DOMAIN_NAME] functionality.

Filename: `supabase/schemas/[NUMBER]-[DOMAIN_NAME].sql`

This file should include:
1. All tables related to the [DOMAIN_NAME] functionality
2. Any views needed for this domain
3. Any functions or triggers specific to these tables
4. All relationships and constraints for these tables

Generate the complete schema file with appropriate table structures, relationships, and constraints for the [DOMAIN_NAME] functionality described in my product requirements.

Place tables in the appropriate schema:
- User-generated content in api schema
- System-generated or sensitive data in internal schema
- Reference data in reference schema

Remember this is a declarative schema file - define the tables in their final desired state.

[NOTE: Repeat this prompt for each domain identified in the initial analysis, replacing [DOMAIN_NAME] and [NUMBER] appropriately.]
```

### 1.4.8: Analytics Schema (Optional)

```
Now I'd like to create the `supabase/schemas/90-analytics.sql` file for very basic and minimal reporting and analytics data, but only if necessary - otherwise leave this file empty.

This optional file should include:
1. Views that aggregate data for reporting purposes

This optional file is for a basic analytics system so should not yet include:
1. Materialized views for complex analytics that are infrequently updated
2. Functions for generating analytics data
3. Any tables specific to analytics storage

Generate the complete `90-analytics.sql` file following these patterns:
- Place analytics structures in the analytics schema
- Create views that join data across different schemas as needed
- Consider performance implications for complex analytics queries

This is a declarative schema file defining the state I want these analytics structures to have. If my application doesn't require analytics views or functions based on the requirements, please indicate that this file can be skipped.
```

### 1.4.9: Audit Schema (Optional)

```
Finally, I'd like to create the `supabase/schemas/91-audit.sql` file for audit tracking and change history.

This optional file should include:
1. Tables for storing audit histories
2. Minimal basic functions and triggers for capturing changes
3. Views for analyzing audit data

Generate the complete `91-audit.sql` file following these patterns:
- Place audit structures in the audit schema
- Implement appropriate timestamp and user tracking
- Consider storage and performance implications for audit history
- Structure tables to capture before/after states as needed

This is a declarative schema file defining the state I want these audit structures to have. If my application doesn't require audit tracking based on the requirements, please indicate that this file can be skipped.
```

### 1.4.10: Configuration Setup

```
To properly organize how my schema files are applied, I need to create a `supabase/config.toml` file that specifies the order of schema application.

Please generate a `config.toml` file that:
1. Ensures schemas are applied in the correct order (foundation first, then profiles, etc.)
2. Includes optional schemas (config, internal, analytics, audit) in the appropriate order
3. Groups core domain schemas to be applied after the foundation schemas
4. Includes a catch-all pattern to ensure any additional schema files are applied

For example:
```toml
[db.migrations]
schema_paths = [
  "./schemas/00-foundation.sql",
  "./schemas/01-profiles.sql",
  "./schemas/02-stripe.sql",
  "./schemas/03-reference.sql",
  "./schemas/04-config.sql",
  "./schemas/05-internal.sql",
  "./schemas/1*.sql",   # All core domain schemas in numeric order
  "./schemas/[2-8]*.sql",  # Any additional domain schemas
  "./schemas/90-analytics.sql",
  "./schemas/91-audit.sql",
  "./schemas/*.sql",    # Any remaining files
]
```

This ensures my schemas are applied in the correct order, with foundational elements first, then core domains, and finally analytics and audit schemas.
```

### 1.4.11: Seed Data

```
Now I need to create a seed.sql file to populate my reference tables with essential data.

This should be a separate file in `supabase/seed.sql` that will be used after applying the schema to provide essential lookup data.

Focus exclusively on:
1. Populating reference or config tables with required values
2. Including standard lookup data the application needs to function
3. NOT inserting any user data or user-generated content
4. Providing only minimal reference data needed for operation

For each reference table, add a comment explaining what data is being inserted and why it's necessary based on my product requirements.

Note that in Supabase's declarative schema approach, DML statements (INSERT, UPDATE, DELETE) are not captured by the schema diff tool. That's why we use a separate seed.sql file for this data.
```

### 1.4.12: Schema Validation

```
Now that I've created all my schema files and seed data, I'd like to validate my schema against the original `product-requirements.md` document and best practices.

Please review the schema files I've created and validate:

1. Completeness check:
   - Are all key entities from the product requirements represented?
   - Have we implemented all necessary relationships?
   - Does the schema support all the main user flows described in the requirements?
   - Is there anything missing from the core business objects?

2. Pattern implementation:
   - Have we correctly organized our schemas according to the patterns?
   - Is financial/billing data appropriately placed in the `internal` schema?
   - Are templates and user-specific instances properly separated between `reference` and `api` schemas?
   - Are we using proper authentication and profile patterns?
   - Have we correctly implemented the required tables for subscriptions or credits?

3. Security considerations:
   - Are there tables that will need Row Level Security (RLS) policies?
   - Is personal user data properly isolated?
   - Are there any potential security concerns with the schema design?

Please identify any gaps, inconsistencies, or areas for improvement in the schema design.
```

### 1.4.13: Installation Instructions

```
Finally, I need clear instructions for using these declarative schema files with Supabase.

Please provide step-by-step instructions for:

1. Setting up the directory structure:
   - Where to place schema files
   - Where to place the config.toml file
   - Where to place the seed.sql file

2. Local development workflow:
   - How to generate migrations from schema files
   - How to apply migrations and seed data locally
   - How to make schema changes and generate incremental migrations

3. Deployment to production:
   - How to push schema changes to a production Supabase instance
   - Best practices for applying schema changes safely

4. Common troubleshooting:
   - How to handle errors during migration generation
   - How to roll back problematic schema changes
   - Known limitations of the declarative schema approach

Please format these instructions as a clear guide that I can include in my project documentation.
```

## Working with Declarative Schemas in Supabase

After generating your schema files, here's the workflow for using them:

1. **Setup directory structure**:
   ```
   supabase/
   ├── schemas/
   │   ├── 00-foundation.sql
   │   ├── 01-profiles.sql
   │   ├── 03-reference.sql
   │   ├── 04-config.sql (optional)
   │   ├── 05-internal.sql (optional)
   │   ├── 10-domain1.sql
   │   ├── 11-domain2.sql
   │   ├── 90-analytics.sql (optional)
   │   └── 91-audit.sql (optional)
   ├── config.toml
   └── seed.sql
   ```

2. **Generate initial migrations**:
   ```bash
   # Stop the local database if it's running
   supabase stop
   
   # Generate the initial migration file
   supabase db diff -f initial_schema
   
   # Start the database to apply migrations
   supabase start
   ```

3. **Apply seed data**:
   ```bash
   # Apply seed data to the database
   psql -h localhost -p 54322 -U postgres -d postgres -f supabase/seed.sql
   ```

4. **Make schema changes**:
   ```bash
   # Stop the database
   supabase stop
   
   # Edit your schema files as needed
   
   # Generate a new migration for the changes
   supabase db diff -f your_change_description
   
   # Apply the new migration
   supabase start && supabase migration up
   ```

5. **Deploy to production**:
   ```bash
   # Log in to Supabase CLI
   supabase login
   
   # Link to your remote project
   supabase link
   
   # Push changes to the remote database
   supabase db push
   ```

If you encounter any errors during migration, check the log output carefully. It will often indicate which table, constraint, or column is causing the issue.

For rolling back a migration during development, you can reset your local database to a previous version:
```bash
supabase db reset --version <timestamp>_<previous_migration>
```

Remember that the `migra` diff tool used for generating schema differences has some limitations. Certain entities like RLS policies, view ownership, grants, and comments are not tracked well by the schema diff and should be handled through versioned migrations instead.